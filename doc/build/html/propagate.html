<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Public API: CHIRALEX package &mdash; Chiralex 0.1beta documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="ToDo list" href="todolist.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html">
            <img src="_static/temp_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="user-guide.html">PECD code user guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="todolist.html">ToDo list</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Public API: CHIRALEX package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#propagation-of-the-wavepacket-propagate">Propagation of the wavepacket (<code class="code docutils literal notranslate"><span class="pre">propagate</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#hamiltonian-module-hamiltonian">Hamiltonian module (<code class="code docutils literal notranslate"><span class="pre">hamiltonian</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#potential-module-potential">Potential module (<code class="code docutils literal notranslate"><span class="pre">potential</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#wavefunction-module-wavefunction">Wavefunction module (<code class="code docutils literal notranslate"><span class="pre">wavefunction</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#electric-field-module-field">Electric field module (<code class="code docutils literal notranslate"><span class="pre">field</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#analysis-module-analyze">Analysis module (<code class="code docutils literal notranslate"><span class="pre">analyze</span></code>)</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Chiralex</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Public API: CHIRALEX package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/propagate.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="public-api-chiralex-package">
<h1>Public API: CHIRALEX package<a class="headerlink" href="#public-api-chiralex-package" title="Permalink to this headline"></a></h1>
<section id="propagation-of-the-wavepacket-propagate">
<h2>Propagation of the wavepacket (<code class="code docutils literal notranslate"><span class="pre">propagate</span></code>)<a class="headerlink" href="#propagation-of-the-wavepacket-propagate" title="Permalink to this headline"></a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pecd.propagate.Propagator" title="pecd.propagate.Propagator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pecd.propagate.Propagator</span></code></a>(params, irun)</p></td>
<td><p>Class contains methods related to the time-propagation of the wavefunction.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pecd.propagate.Propagator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pecd.propagate.</span></span><span class="sig-name descname"><span class="pre">Propagator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irun</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.propagate.Propagator" title="Permalink to this definition"></a></dt>
<dd><p>Class contains methods related to the time-propagation of the wavefunction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> – str
fdsfsd</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>thresh<span class="classifier">float</span></dt><dd><p>fdsf</p>
</dd>
</dl>
</dd>
<dt>Attrs:</dt><dd><dl class="simple">
<dt>params<span class="classifier">dict</span></dt><dd><p>Keeps relevant parameters.</p>
</dd>
<dt>irun<span class="classifier">int</span></dt><dd><p>id of the run over the Euler grid</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pecd.propagate.Propagator.gen_timegrid">
<span class="sig-name descname"><span class="pre">gen_timegrid</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pecd.propagate.Propagator.gen_timegrid" title="Permalink to this definition"></a></dt>
<dd><p>Calculates equidistant time-grid for the wavefunction proapgation.
Start and end points are included in the grid.</p>
<dl class="simple">
<dt>Returns: tuple</dt><dd><dl class="simple">
<dt>tgrid: numpy 1D array</dt><dd><p>time grid array</p>
</dd>
<dt>dt: float</dt><dd><p>time step</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>If t0=0.0 and tmax = 10.0 and dt = 1.0 the grid has 11 elements:
[ 0.  1.  2.  3.  4.  5.  6.  7.  8.  9. 10.]</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.propagate.Propagator.prop_wf">
<span class="sig-name descname"><span class="pre">prop_wf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ham_init</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dipmat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi_init</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.propagate.Propagator.prop_wf" title="Permalink to this definition"></a></dt>
<dd><p>This function propagates the wavefunction with the time-dependent Hamiltonian and saves the wavepacket in a file.</p>
<p>Here the time-grid and the electric fields are constructed. The wavefunction is propagated by an iterative
calculation of the product of the time-dependent Hamiltonian matrix exponential and the wavefunction vector:</p>
<div class="math notranslate nohighlight" id="equation-wf-propagation">
<span class="eqno">(1)<a class="headerlink" href="#equation-wf-propagation" title="Permalink to this equation"></a></span>\[\psi(t_{i+1}) = \exp(-i\cdot H(t) \cdot dt) \psi(t_i)\]</div>
<dl class="simple">
<dt>Arguments: tuple</dt><dd><dl class="simple">
<dt>ham_init<span class="classifier">scipy.sparse.csr_matrix, dtype = complex/float, shape = (Nbas,Nbas)</span></dt><dd><p>Initial Hamiltonian matrix</p>
</dd>
<dt>intmat<span class="classifier">scipy.sparse.csr_matrix, dtype = complex, shape = (Nbas,Nbas)</span></dt><dd><p>electric dipole interaction matrix (with no field included)</p>
</dd>
<dt>psi_init<span class="classifier">numpy.ndarray, dtype = complex, shape = (Nbas,)</span></dt><dd><p>initial wavefunction</p>
</dd>
</dl>
</dd>
</dl>
<p>Returns: None</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The initial Hamiltonian <cite>ham_init</cite> <code class="xref py py-func docutils literal notranslate"><span class="pre">Hamiltonian.build_ham()</span></code> has complex matrix elements in general. However the kinetic energy matrix constructed in <code class="xref py py-func docutils literal notranslate"><span class="pre">Hamiltonian.build_keo()</span></code> is real by construction. Therefore when the potential matrix calculated in <code class="xref py py-func docutils literal notranslate"><span class="pre">Hamiltonian.build_potmat()</span></code> is real, the Hamiltonian matrix is real too.</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="hamiltonian-module-hamiltonian">
<h2>Hamiltonian module (<code class="code docutils literal notranslate"><span class="pre">hamiltonian</span></code>)<a class="headerlink" href="#hamiltonian-module-hamiltonian" title="Permalink to this headline"></a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pecd.hamiltonian.Hamiltonian" title="pecd.hamiltonian.Hamiltonian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pecd.hamiltonian.Hamiltonian</span></code></a>(params, WDMATS)</p></td>
<td><p>Hamiltonian class keeps methods for generating and manipulating matrices: kinetic energy operator, potential energy operator, hamiltonian, dipole interaction operator.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pecd.hamiltonian.Hamiltonian">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pecd.hamiltonian.</span></span><span class="sig-name descname"><span class="pre">Hamiltonian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">WDMATS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hamtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'bound'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.hamiltonian.Hamiltonian" title="Permalink to this definition"></a></dt>
<dd><p>Hamiltonian class keeps methods for generating and manipulating matrices: kinetic energy operator, potential energy operator, hamiltonian, dipole interaction operator.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The characteristics of the photo-electron propagation using the FEM-DVR method suggests
that a DVR-type mapping is suitable and natural.</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="pecd.hamiltonian.Hamiltonian.hamtype">
<span class="sig-name descname"><span class="pre">hamtype</span></span><a class="headerlink" href="#pecd.hamiltonian.Hamiltonian.hamtype" title="Permalink to this definition"></a></dt>
<dd><p>‘bound’ or ‘prop’ determines the type of the hamiltonian to be created</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pecd.hamiltonian.Hamiltonian.params">
<span class="sig-name descname"><span class="pre">params</span></span><a class="headerlink" href="#pecd.hamiltonian.Hamiltonian.params" title="Permalink to this definition"></a></dt>
<dd><p>standard input parameters dictionary</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>dics</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.hamiltonian.Hamiltonian.build_dmat">
<span class="sig-name descname"><span class="pre">build_dmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.hamiltonian.Hamiltonian.build_dmat" title="Permalink to this definition"></a></dt>
<dd><p>Constructs the D-matrix of derivatives of Lagrange polynomials evaluated at Gauss-Lobatto quadrature nodes.</p>
<p>The D-matrix is defined as</p>
<blockquote>
<div><div class="math notranslate nohighlight" id="equation-d-matrix">
<span class="eqno">(2)<a class="headerlink" href="#equation-d-matrix" title="Permalink to this equation"></a></span>\[D_{kn} = L'_n(x_k)\]</div>
<dl class="simple">
<dt>Arguments: numpy.ndarray, dtype = float, shape = (Nl,)</dt><dd><p>x : quadrature nodes</p>
</dd>
<dt>Returns: numpy.ndarray</dt><dd><dl class="simple">
<dt>Dmat :numpy.ndarray</dt><dd><p>The D-matrix</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.hamiltonian.Hamiltonian.build_keomat_blocks">
<span class="sig-name descname"><span class="pre">build_keomat_blocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">KD0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">KC0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">CFE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nang</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.hamiltonian.Hamiltonian.build_keomat_blocks" title="Permalink to this definition"></a></dt>
<dd><p>Create compressed sparse-row matrix from copies of the generic inflated KD and KC matrices + the CFE term.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>KD0</strong> (<em>2D numpy array</em>) – inflated KD matrix</p></li>
<li><p><strong>KC0</strong> (<em>2D numpy array</em>) – inflated KC matrix</p></li>
<li><p><strong>CFE</strong> (<em>1D numpy array</em>) – The centrifugal term</p></li>
<li><p><strong>nbins</strong> (<em>float</em>) – number of bins</p></li>
<li><p><strong>Nu</strong> (<em>float</em>) – number of points per block (Nang*(nlobs-1))</p></li>
<li><p><strong>Nang</strong> (<em>float</em>) – size of the angular basis</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the KEO operator matrix in csr format</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>keomat (2D sparse csr array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.hamiltonian.Hamiltonian.build_jmat">
<span class="sig-name descname"><span class="pre">build_jmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.hamiltonian.Hamiltonian.build_jmat" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.hamiltonian.Hamiltonian.gen_klist">
<span class="sig-name descname"><span class="pre">gen_klist</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pecd.hamiltonian.Hamiltonian.gen_klist" title="Permalink to this definition"></a></dt>
<dd><p>Generates a list of non-zero indices in the KEO matrix</p>
<dl class="simple">
<dt>Returns: list</dt><dd><dl class="simple">
<dt>klist: 1D list</dt><dd><p>list [i1,n1,i2,n2,l2,p1,p2]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.hamiltonian.Hamiltonian.calc_vxi">
<span class="sig-name descname"><span class="pre">calc_vxi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vmat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmats</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.hamiltonian.Hamiltonian.calc_vxi" title="Permalink to this definition"></a></dt>
<dd><p>Calculate a block of the potential energy matrix for a single grid point. Uses multipole expansion as given in Demekhin et al.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vmats</strong> (<em>1D numpy array</em><em>, </em><em>shape=</em><em>(</em><em>Nmulti</em><em>)</em>) – Nmulti = (Lmax+1)^2, values of the radial potential at a single grid point.</p></li>
<li><p><strong>tmats</strong> (<em>3D numpy array</em><em>, </em><em>shape=</em><em>(</em><em>Nang</em><em>,</em><em>Nang</em><em>,</em><em>Nmulti</em><em>)</em>) – tjmat reduced to 3 dimensions</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Returns: numpy.ndarray, dtype = complex, shape = (Nang,Nang)</dt><dd><p>vxi: 2D numpy array keeping the matrix elements of the potential energy for a given radial grid point</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.hamiltonian.Hamiltonian.gen_tjmat">
<span class="sig-name descname"><span class="pre">gen_tjmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lmax_basis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lmax_multi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.hamiltonian.Hamiltonian.gen_tjmat" title="Permalink to this definition"></a></dt>
<dd><p>precompute all necessary 3-j symbols for the matrix elements of the multipole moments</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.hamiltonian.Hamiltonian.build_potmat_chiralium_anton">
<span class="sig-name descname"><span class="pre">build_potmat_chiralium_anton</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid_euler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irun</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.hamiltonian.Hamiltonian.build_potmat_chiralium_anton" title="Permalink to this definition"></a></dt>
<dd><p>Build the potential energy matrix using the analytic method with the ESP read from files provided by A. Artemyev.</p>
<p>See theory docs for more detailes.</p>
<dl class="simple">
<dt>Returns: sparse matrix</dt><dd><dl class="simple">
<dt>potmat sparse matrix, dtype = complex, shape = (Nbas,Nbas)</dt><dd><p>potential energy matrix</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For this function to work a set of ESP files in ./potential/ directory must be provided.</p>
</div>
<p class="rubric">Examples</p>
<p>Below are given example structures of the potential energy matrix:</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/potmat_example_zoom1.png"><img alt="_images/potmat_example_zoom1.png" src="_images/potmat_example_zoom1.png" style="width: 400px; height: 400px;" /></a>
</figure>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/potmat_example_zoom2.png"><img alt="_images/potmat_example_zoom2.png" src="_images/potmat_example_zoom2.png" style="width: 400px; height: 400px;" /></a>
</figure>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/potmat_example_zoom3.png"><img alt="_images/potmat_example_zoom3.png" src="_images/potmat_example_zoom3.png" style="width: 400px; height: 400px;" /></a>
</figure>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.hamiltonian.Hamiltonian.gen_3j_dip">
<span class="sig-name descname"><span class="pre">gen_3j_dip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lmax</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mode</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.hamiltonian.Hamiltonian.gen_3j_dip" title="Permalink to this definition"></a></dt>
<dd><p>Precompute all necessary <span class="math notranslate nohighlight">\(h_{ll'mm'\mu}\)</span> dipole matrix elements.</p>
<blockquote>
<div><p>Perform the following Legendre decomposition:</p>
<div class="math notranslate nohighlight">
\[h_{ll'mm'\mu} = (-1)^m\sqrt{\]</div>
</div></blockquote>
<dl>
<dt>rac{3}{4pi}}sqrt{(2l+1)(2l’+1)} egin{pmatrix}</dt><dd><blockquote>
<div><blockquote>
<div><p>l &amp; 1 &amp; l’ m’ &amp; -mu &amp; -m
end{pmatrix}}</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">label</dt>
<dd class="field-odd"><p>dipole_matrix</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns: numpy.ndarray</dt><dd><p>tjmat : numpy.ndarray, dtype = float, shape = (lmax + 1, lmax + 1, 2*lmax + 1, 2*lmax + 1, 3)</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.hamiltonian.Hamiltonian.map_tjmat_dip">
<span class="sig-name descname"><span class="pre">map_tjmat_dip</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tjmat</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.hamiltonian.Hamiltonian.map_tjmat_dip" title="Permalink to this definition"></a></dt>
<dd><p>Map the 5D dipole’s tjmat onto a practical 3D numpy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tjmat</strong> (<em>5D numpy array</em>) – matrix elements of the respective spherical harmonics operators in the spherical harmonics basis</p>
</dd>
</dl>
<dl class="simple">
<dt>Returns: array</dt><dd><p>tjmats (3D numpy array, shape=(Nang,Nang,Nr)): tjmat reduced to 3 dimensions</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.hamiltonian.Hamiltonian.build_intmat">
<span class="sig-name descname"><span class="pre">build_intmat</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pecd.hamiltonian.Hamiltonian.build_intmat" title="Permalink to this definition"></a></dt>
<dd><p>Driver routine for the calculation of the dipole interaction energy matrix.</p>
<dl class="simple">
<dt>Returns: numpy.ndarray</dt><dd><p>intmat : numpy.ndarray, dtype = float, shape = (Nbas,Nbas)</p>
</dd>
</dl>
<p>An example plot of the dipole interaction matrix for CPL is given below:</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/dipmat_example1.png"><img alt="_images/dipmat_example1.png" src="_images/dipmat_example1.png" style="width: 400px; height: 400px;" /></a>
</figure>
<p>this matrix is not Hermitian. The symmetrized dipole interaction matrix is shown below:</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/dipmat_example2.png"><img alt="_images/dipmat_example2.png" src="_images/dipmat_example2.png" style="width: 400px; height: 400px;" /></a>
</figure>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.hamiltonian.Hamiltonian.calc_dipxi">
<span class="sig-name descname"><span class="pre">calc_dipxi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmats</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.hamiltonian.Hamiltonian.calc_dipxi" title="Permalink to this definition"></a></dt>
<dd><p>Calculate a block of the electric dipole interaction matrix for a single grid point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vmats</strong> (<em>1D numpy array</em><em>, </em><em>shape=</em><em>(</em><em>Nmulti</em><em>)</em>) – Nmulti = (Lmax+1)^2, values of the radial potential at a single grid point.</p></li>
<li><p><strong>tmats</strong> (<em>3D numpy array</em><em>, </em><em>shape=</em><em>(</em><em>Nang</em><em>,</em><em>Nang</em><em>,</em><em>Nr</em><em>)</em>) – tjmat reduced to 3 dimensions</p></li>
</ul>
</dd>
</dl>
<dl class="simple">
<dt>Returns: numpy.ndarray, dtype = float, shape=(Nmulti,Nmulti)): Nmulti = (Lmax+1)^2</dt><dd><p>dipxi : array of dipole matrix lements labeled by the angular coordinate</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="potential-module-potential">
<h2>Potential module (<code class="code docutils literal notranslate"><span class="pre">potential</span></code>)<a class="headerlink" href="#potential-module-potential" title="Permalink to this headline"></a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
</tbody>
</table>
</section>
<section id="wavefunction-module-wavefunction">
<h2>Wavefunction module (<code class="code docutils literal notranslate"><span class="pre">wavefunction</span></code>)<a class="headerlink" href="#wavefunction-module-wavefunction" title="Permalink to this headline"></a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pecd.wavefunction.Map" title="pecd.wavefunction.Map"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pecd.wavefunction.Map</span></code></a>(femlist, map_type, job_dir)</p></td>
<td><p>Map class keeps methods for generating and manipulating index mapping for the wavefunction and matrices.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pecd.wavefunction.GridRad" title="pecd.wavefunction.GridRad"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pecd.wavefunction.GridRad</span></code></a>(nlobs, nbins, ...)</p></td>
<td><p>Class contains methods related to the radial grid.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pecd.wavefunction.GridEuler" title="pecd.wavefunction.GridEuler"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pecd.wavefunction.GridEuler</span></code></a>(N_euler, ...)</p></td>
<td><p>GridEuler class keeps methods for generating and manipulating the grid of molecular orientations</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pecd.wavefunction.Psi" title="pecd.wavefunction.Psi"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pecd.wavefunction.Psi</span></code></a>(params, WDMATS, ...[, ...])</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pecd.wavefunction.Map">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pecd.wavefunction.</span></span><span class="sig-name descname"><span class="pre">Map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">femlist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">map_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">job_dir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.wavefunction.Map" title="Permalink to this definition"></a></dt>
<dd><p>Map class keeps methods for generating and manipulating index mapping for the wavefunction and matrices.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The characteristics of the photo-electron propagation using the FEM-DVR method suggests
that a DVR-type mapping is suitable and natural.</p>
</div>
<dl class="py attribute">
<dt class="sig sig-object py" id="pecd.wavefunction.Map.femlist">
<span class="sig-name descname"><span class="pre">femlist</span></span><a class="headerlink" href="#pecd.wavefunction.Map.femlist" title="Permalink to this definition"></a></dt>
<dd><p>keeps sizes of radial bins and the number of points/functions in each bin.
Format: [ [nbins,nlobs,Rbin], … ].</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pecd.wavefunction.Map.map_type">
<span class="sig-name descname"><span class="pre">map_type</span></span><a class="headerlink" href="#pecd.wavefunction.Map.map_type" title="Permalink to this definition"></a></dt>
<dd><p>type of mapping function (‘DVR’ , ‘DVR_NAT’ or ‘SPECT’)</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pecd.wavefunction.Map.job_dir">
<span class="sig-name descname"><span class="pre">job_dir</span></span><a class="headerlink" href="#pecd.wavefunction.Map.job_dir" title="Permalink to this definition"></a></dt>
<dd><p>path to current working directory</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lmax</strong> (<em>int</em>) – maximum value of the l quantum number</p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pecd.wavefunction.Map.genmap_femlist">
<span class="sig-name descname"><span class="pre">genmap_femlist</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pecd.wavefunction.Map.genmap_femlist" title="Permalink to this definition"></a></dt>
<dd><p>Driver routine to call map generators.</p>
<dl class="simple">
<dt>Returns: tuple</dt><dd><dl class="simple">
<dt>maparray: list</dt><dd><p>[[ibin,n,ipoint,l,m,id],…]</p>
</dd>
<dt>Nbas: int</dt><dd><p>Total number of basis functions</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.wavefunction.Map.map_dvr_femlist_nat">
<span class="sig-name descname"><span class="pre">map_dvr_femlist_nat</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pecd.wavefunction.Map.map_dvr_femlist_nat" title="Permalink to this definition"></a></dt>
<dd><p>Generates an index map with grid points as major dimension and bridge points/functions placed as last in the bin.</p>
<dl>
<dt>Returns: tuple</dt><dd><p>maparray: list</p>
<div class="math notranslate nohighlight">
\[i,n,l,m -&gt; M(i,n,l,m)\]</div>
<p>in the following format [[<cite>ibin</cite>,`n`,`ipoint`,`l`,`m`,`id`],…]</p>
<dl class="simple">
<dt>Nbas: int</dt><dd><p>Total number of basis functions</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.wavefunction.Map.gen_sphlist">
<span class="sig-name descname"><span class="pre">gen_sphlist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lmax</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.wavefunction.Map.gen_sphlist" title="Permalink to this definition"></a></dt>
<dd><p>Generates a list of basis set indices for adaptive quadratures.</p>
<dl class="simple">
<dt>Returns: list</dt><dd><dl class="simple">
<dt>sphlist: list</dt><dd><p>list of angular indices [l,m]</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pecd.wavefunction.GridRad">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pecd.wavefunction.</span></span><span class="sig-name descname"><span class="pre">GridRad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nlobs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">binwidth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rshift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.wavefunction.GridRad" title="Permalink to this definition"></a></dt>
<dd><p>Class contains methods related to the radial grid.</p>
<dl class="simple">
<dt>Attrs:</dt><dd><dl class="simple">
<dt>nlobs<span class="classifier">int</span></dt><dd><p>number of Gauss-Lobatto functions per bin</p>
</dd>
<dt>nbins<span class="classifier">int</span></dt><dd><p>number of bins</p>
</dd>
<dt>binwidth<span class="classifier">float</span></dt><dd><p>width (a.u.) of the bin</p>
</dd>
<dt>rshift<span class="classifier">float</span></dt><dd><p>shift of the grid (a.u.)</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pecd.wavefunction.GridRad.gen_grid">
<span class="sig-name descname"><span class="pre">gen_grid</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pecd.wavefunction.GridRad.gen_grid" title="Permalink to this definition"></a></dt>
<dd><p>Generates radial grid based on Gauss-Lobatto quadrature points,=.Three grids are returned: quadrature grid, primitive grid, coupled grid used in final calculation.</p>
<dl class="simple">
<dt>Returns: tuple</dt><dd><dl class="simple">
<dt>x: numpy 1D array (float, size = nlobs)</dt><dd><p>Gauss-lobatto quadrature grid</p>
</dd>
<dt>w: numpy 1D array (float, size = nlobs)</dt><dd><p>Gauss-lobatto quadrature weights</p>
</dd>
</dl>
</dd>
<dt>rgrid_prim: numpy 1D array (float, size = nlobs * nbins)</dt><dd><p>Primitive radial grid containing all grid points, plus point values at bin boundries are duplicated i.e. first point in the bin has equal value to last point from previous bin.</p>
</dd>
<dt>rgrid: numpy 1D array (float, size = Nr = (nlobs - 1)*nbins - 1)</dt><dd><p>Coupled radial grid with boundary points excluded and no duplicate points at bin boundaries.</p>
</dd>
<dt>Nr: int</dt><dd><p>number of coupled grid points</p>
</dd>
</dl>
<p>Todo: this function must be generalized to account for FEMLIST. Presently only constant bin size is possible.</p>
<p>Status: tested</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pecd.wavefunction.GridEuler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pecd.wavefunction.</span></span><span class="sig-name descname"><span class="pre">GridEuler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">N_euler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">N_batches</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_type</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.wavefunction.GridEuler" title="Permalink to this definition"></a></dt>
<dd><p>GridEuler class keeps methods for generating and manipulating the grid of molecular orientations</p>
<dl class="py attribute">
<dt class="sig sig-object py" id="pecd.wavefunction.GridEuler.N_euler">
<span class="sig-name descname"><span class="pre">N_euler</span></span><a class="headerlink" href="#pecd.wavefunction.GridEuler.N_euler" title="Permalink to this definition"></a></dt>
<dd><p>number of molecular molecular orientations per dimension</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pecd.wavefunction.GridEuler.N_batches">
<span class="sig-name descname"><span class="pre">N_batches</span></span><a class="headerlink" href="#pecd.wavefunction.GridEuler.N_batches" title="Permalink to this definition"></a></dt>
<dd><p>number of batches into which the full run is divided</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pecd.wavefunction.GridEuler.grid_type">
<span class="sig-name descname"><span class="pre">grid_type</span></span><a class="headerlink" href="#pecd.wavefunction.GridEuler.grid_type" title="Permalink to this definition"></a></dt>
<dd><p>2D or 3D grid type. For 2D the first Euler angle (alpha) is fixed at 0.0.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.wavefunction.GridEuler.gen_euler_grid">
<span class="sig-name descname"><span class="pre">gen_euler_grid</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pecd.wavefunction.GridEuler.gen_euler_grid" title="Permalink to this definition"></a></dt>
<dd><p>Generates the 3D Cartesian product of 1D grids of Euler angles.</p>
<dl class="simple">
<dt>Returns: tuple</dt><dd><dl class="simple">
<dt>euler_grid: numpy 3D array</dt><dd><p>grid of euler angles [alpha,beta,gamma]</p>
</dd>
<dt>n_euler: int</dt><dd><p>the total number of grid points</p>
</dd>
</dl>
</dd>
</dl>
<p>Status: tested</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.wavefunction.GridEuler.gen_euler_grid_2D">
<span class="sig-name descname"><span class="pre">gen_euler_grid_2D</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pecd.wavefunction.GridEuler.gen_euler_grid_2D" title="Permalink to this definition"></a></dt>
<dd><p>Generates the 2D Cartesian product of 1D grids of Euler angles.</p>
<dl class="simple">
<dt>Returns: tuple</dt><dd><dl class="simple">
<dt>euler_grid: numpy 2D array</dt><dd><p>grid of euler angles [alpha=0.0,beta,gamma]</p>
</dd>
<dt>n_euler: int</dt><dd><p>the total number of grid points</p>
</dd>
</dl>
</dd>
</dl>
<p>Status: tested.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.wavefunction.GridEuler.read_euler_grid">
<span class="sig-name descname"><span class="pre">read_euler_grid</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pecd.wavefunction.GridEuler.read_euler_grid" title="Permalink to this definition"></a></dt>
<dd><p>Read the Euler grid from file and put it in a correct shape.</p>
<dl class="simple">
<dt>Returns: numpy.ndarray, dtype = float, shape = (N_euler,3)</dt><dd><p>grid_euler: numpy array keeping the Euler angles</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pecd.wavefunction.Psi">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pecd.wavefunction.</span></span><span class="sig-name descname"><span class="pre">Psi</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">WDMATS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grid_euler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irun</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psitype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'bound'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.wavefunction.Psi" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pecd.wavefunction.Psi.project_psi_global">
<span class="sig-name descname"><span class="pre">project_psi_global</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">psi0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.wavefunction.Psi.project_psi_global" title="Permalink to this definition"></a></dt>
<dd><p>Projects the bound wavefunction onto the propagation Hilbert space.</p>
<p>We assume that the bound wavefunction is zero outside the inner region defined by <span class="math notranslate nohighlight">\(R_{bound}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\psi(r \geq R_{bound},t=0) = 0\]</div>
<div class="math notranslate nohighlight" id="equation-psi-init">
<span class="eqno">(3)<a class="headerlink" href="#equation-psi-init" title="Permalink to this equation"></a></span>\[\psi(r,t=0)|_{r&lt;R_{bound}} = \psi_0\]</div>
<dl class="simple">
<dt>Arguments: numpy.ndarray</dt><dd><dl class="simple">
<dt>psi0: numpy.ndarray, dtype = <cite>float</cite>, shape = (<cite>Nbas0</cite>,)</dt><dd><p>Bound state wavefunction stored in 1D numpy array.</p>
</dd>
</dl>
</dd>
<dt>Returns: numpy.ndarray, dtype = complex, shape = (Nbas,)</dt><dd><p>psi: initial wavefunction in the propagation space</p>
</dd>
</dl>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The size of the inner space <span class="math notranslate nohighlight">\(R_{bound}\)</span> must be <strong>large enough</strong>, such that no significant electron density leaks are observed in the field-free evolution of the initial wavefunciton.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Future implementations may consider linking an externally calculated bound electron wavefunction projected onto the FEM-DVR basis.</p>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="electric-field-module-field">
<h2>Electric field module (<code class="code docutils literal notranslate"><span class="pre">field</span></code>)<a class="headerlink" href="#electric-field-module-field" title="Permalink to this headline"></a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pecd.field.Field" title="pecd.field.Field"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pecd.field.Field</span></code></a>(params)</p></td>
<td><p>Class representing the electric field</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pecd.field.Field">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pecd.field.</span></span><span class="sig-name descname"><span class="pre">Field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.field.Field" title="Permalink to this definition"></a></dt>
<dd><p>Class representing the electric field</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> – str
Name of the HDF5 file from which tensor data is loaded.</p>
</dd>
</dl>
<dl class="simple">
<dt>Kwargs:</dt><dd><dl class="simple">
<dt>thresh<span class="classifier">float</span></dt><dd><p>Threshold for neglecting matrix elements when reading from file</p>
</dd>
</dl>
</dd>
<dt>Attrs:</dt><dd><dl class="simple">
<dt>params<span class="classifier">dict</span></dt><dd><p>Dictionary of parameters</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="pecd.field.Field.gen_field">
<span class="sig-name descname"><span class="pre">gen_field</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.field.Field.gen_field" title="Permalink to this definition"></a></dt>
<dd><p>Main routine for the generation of the electric field.</p>
<dl class="simple">
<dt>Arguments: numpy.ndarray</dt><dd><dl class="simple">
<dt>t<span class="classifier">numpy.ndarray, dtype=float, shape=(Ntime,)</span></dt><dd><p>time grid</p>
</dd>
</dl>
</dd>
<dt>Returns: numpy.ndarray</dt><dd><dl class="simple">
<dt>Fvec: numpy.ndarray, dtype = complex, shape = (Ntime,3)</dt><dd><p>Vector of the electric field components (-1,0,+1)</p>
</dd>
</dl>
</dd>
</dl>
<p>Table of quantities:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 30%" />
<col style="width: 48%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Component</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Fvec[:,0]</p></td>
<td><p>complex</p></td>
<td><p><span class="math notranslate nohighlight">\(E_{-1}(t)\)</span></p></td>
</tr>
<tr class="row-odd"><td><p>Fvec[:,1]</p></td>
<td><p>complex</p></td>
<td><p><span class="math notranslate nohighlight">\(E_{0}(t)\)</span></p></td>
</tr>
<tr class="row-even"><td><p>Fvec[:,2]</p></td>
<td><p>complex</p></td>
<td><p><span class="math notranslate nohighlight">\(E_{+1}(t)\)</span></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

</dd></dl>

</section>
<section id="analysis-module-analyze">
<h2>Analysis module (<code class="code docutils literal notranslate"><span class="pre">analyze</span></code>)<a class="headerlink" href="#analysis-module-analyze" title="Permalink to this headline"></a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pecd.analyze.analysis" title="pecd.analyze.analysis"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pecd.analyze.analysis</span></code></a>(params, helicity)</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pecd.analyze.momentumfuncs" title="pecd.analyze.momentumfuncs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">pecd.analyze.momentumfuncs</span></code></a>(params, helicity)</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="pecd.analyze.analysis">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pecd.analyze.</span></span><span class="sig-name descname"><span class="pre">analysis</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">helicity</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.analyze.analysis" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pecd.analyze.analysis.read_wavepacket">
<span class="sig-name descname"><span class="pre">read_wavepacket</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tgrid_plot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Nbas</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.analyze.analysis.read_wavepacket" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.analyze.analysis.momentum_au_to_energy_ev">
<span class="sig-name descname"><span class="pre">momentum_au_to_energy_ev</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.analyze.analysis.momentum_au_to_energy_ev" title="Permalink to this definition"></a></dt>
<dd><p>Converts momentum given in atomic units to energy in eV</p>
<blockquote>
<div><dl class="simple">
<dt>Arguments: numpy.ndarray</dt><dd><dl class="simple">
<dt>array<span class="classifier">numpy.ndarray, dtype = float, shape = (N,)</span></dt><dd><p>grid of momenta given in a.u.</p>
</dd>
</dl>
</dd>
<dt>Returns: numpu.ndarray</dt><dd><p>energy :math:<a href="#id1"><span class="problematic" id="id2">`</span></a>E=</p>
</dd>
</dl>
</div></blockquote>
<p>rac{1}{2}k^2` in <cite>eV</cite>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.analyze.analysis.energy_ev_to_momentum_au">
<span class="sig-name descname"><span class="pre">energy_ev_to_momentum_au</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">array</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.analyze.analysis.energy_ev_to_momentum_au" title="Permalink to this definition"></a></dt>
<dd><p>Converts energy array given in eV to momentum array given in atomic units</p>
<dl class="simple">
<dt>Arguments: numpy.ndarray</dt><dd><dl class="simple">
<dt>array<span class="classifier">numpy.ndarray, dtype = float, shape = (N,)</span></dt><dd><p>grid of energies given in eV</p>
</dd>
</dl>
</dd>
<dt>Returns: numpu.ndarray</dt><dd><p>momentum <span class="math notranslate nohighlight">\(k = 2\sqrt{E}\)</span> in <cite>au</cite>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pecd.analyze.momentumfuncs">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pecd.analyze.</span></span><span class="sig-name descname"><span class="pre">momentumfuncs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">helicity</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.analyze.momentumfuncs" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="pecd.analyze.momentumfuncs.W2D">
<span class="sig-name descname"><span class="pre">W2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">funcpars</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.analyze.momentumfuncs.W2D" title="Permalink to this definition"></a></dt>
<dd><p>2D electron momentum probability distribution</p>
<p>A 2D slice <span class="math notranslate nohighlight">\(W(k,\lambda)\)</span> of the full 3D probability distribution <span class="math notranslate nohighlight">\(W(k, \tilde{\theta}, \tilde{\phi})\)</span> is calculated. We give a choice for the plane in which the slice is calculated: <cite>XY</cite>, <cite>XZ</cite> or <cite>YZ</cite>.</p>
<dl class="simple">
<dt>Arguments: dict</dt><dd><dl class="simple">
<dt>funcpars<span class="classifier">dict</span></dt><dd><p>A dictionary with all relevant W2D function parameters</p>
</dd>
</dl>
</dd>
</dl>
<p>Returns: None</p>
<p>An example distribution is plotted below:</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/W2Dav_example.png"><img alt="_images/W2Dav_example.png" src="_images/W2Dav_example.png" style="width: 400px; height: 400px;" /></a>
</figure>
<p>Table of slicing planes:</p>
<blockquote>
<div><table class="docutils align-default">
<colgroup>
<col style="width: 14%" />
<col style="width: 43%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Plane</p></th>
<th class="head"><p>Form</p></th>
<th class="head"><p>Fixed angle</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><cite>XY</cite></p></td>
<td><p><span class="math notranslate nohighlight">\(W(k,\tilde{\phi})\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\tilde{\theta} = \pi/2\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><cite>XZ</cite></p></td>
<td><p><span class="math notranslate nohighlight">\(W(k,\tilde{\theta})\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\tilde{\phi} = 0\)</span></p></td>
</tr>
<tr class="row-even"><td><p><cite>YZ</cite></p></td>
<td><p><span class="math notranslate nohighlight">\(W(k,\tilde{\theta})\)</span></p></td>
<td><p><span class="math notranslate nohighlight">\(\tilde{\phi} = \pi/2\)</span></p></td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.analyze.momentumfuncs.W2D_calc">
<span class="sig-name descname"><span class="pre">W2D_calc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">funcpar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Flm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ft_polargrid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.analyze.momentumfuncs.W2D_calc" title="Permalink to this definition"></a></dt>
<dd><p>Calculate numerically <span class="math notranslate nohighlight">\(W_{2D}(k,\tilde{\theta};\tilde{\phi}_0)\)</span> for a fixed angle.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>W2D</cite> is a numpy.ndarray (complex) of shape (FT_npts_k, FT_npts_th). It is <strong>always</strong> defined on the original radial Hankel grid.</p>
</div>
<dl class="simple">
<dt>Arguments: dict</dt><dd><dl class="simple">
<dt>funcpars<span class="classifier">dict</span></dt><dd><p>A dictionary with all relevant W2Dav function parameters</p>
</dd>
<dt>Flm: numpy.ndarray, dtype = complex, shape = (FT_npts_k,)</dt><dd><p>Array of radial FT amplitudes calculated calculated with Hankel transform</p>
</dd>
<dt>ft_polargrid: numpy.ndarray, shape = (FT_npts_k, FT_npts_th)</dt><dd><p>2D polar grid or <span class="math notranslate nohighlight">\((k,\tilde{\theta})\)</span></p>
</dd>
</dl>
</dd>
<dt>Returns: dict</dt><dd><dl class="simple">
<dt>W2Ddir<span class="classifier">dict</span></dt><dd><p>A dictionary keeping numpy arrays of W2D for requested evaluation planes: ‘XY’,’XZ’ or ‘YZ’.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.analyze.momentumfuncs.W2D_plot">
<span class="sig-name descname"><span class="pre">W2D_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">funcpars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ft_polargrid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W2D</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.analyze.momentumfuncs.W2D_plot" title="Permalink to this definition"></a></dt>
<dd><p>Produces a contour 2D plot for 2D electron’s momentum distribution <span class="math notranslate nohighlight">\(W_{2D}(k,\tilde{\theta})\)</span> evaluated at planes ‘XY’, ‘XZ’ or ‘YZ’.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the present implementation the 2D controur plot is produced for the <strong>original FT</strong> grid, not for the grid defined by the user. User-defined grid determines ranges and ticks only.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>contourf</cite> already performs interpolation of W2D. There is no need for evaluation of W2D on a finer grid than ft_polargrid.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.analyze.momentumfuncs.PES">
<span class="sig-name descname"><span class="pre">PES</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">funcpars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ft_polargrid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irun</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.analyze.momentumfuncs.PES" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the photo-electron spectrum (PES) from a 2D momentum distribution.</p>
<p>Perform the following integration:</p>
<div class="math notranslate nohighlight" id="equation-pes-definition">
<span class="eqno">(4)<a class="headerlink" href="#equation-pes-definition" title="Permalink to this equation"></a></span>\[\sigma(E) = \int \sin\theta d\theta W_{2D}(E,\tilde{\theta})\]</div>
<p>This function carries options for:
a) saving the PES for a chosen momentum grid (<cite>save_PES=True</cite>)
b) psaving the PES for a chosen momentum grid (<cite>plot_PES=True</cite>)</p>
<dl class="simple">
<dt>Parameters: dict</dt><dd><dl class="simple">
<dt>pes_max_k: float</dt><dd><p>maximum range for the PES plot. It is independent of the respective momentum range set for W2Dav, but cannot exceed the FT range determined by the number of FT points.</p>
</dd>
</dl>
</dd>
<dt>Arguments: tuple</dt><dd><dl class="simple">
<dt>funcpars<span class="classifier">dict</span></dt><dd><p>parent function parameters. This includes <cite>funcpars[‘ktuple’]</cite> and <cite>funcpars[‘thtuple’]</cite>, which determine plotting ranges.</p>
</dd>
<dt>ft_polargrid<span class="classifier">numpy.ndarray, dtype = float, shape = ()</span></dt><dd><p>polar meshgrid over which the input distribution is defined. It has the shape = (FT_npts_k,npts_theta). The numer of angular points is arbitrary, as defined by the user in <cite>th_grid</cite>. The number of radial points is determined by the number of points used to calculate the Hankel transform.</p>
</dd>
<dt>fdir<span class="classifier">dict</span></dt><dd><p>A dictionary containing {‘plane’:W2D[plane]}’ where W2D is numpy.ndarray, dtype = float, shape = (FT_npts_k,npts_the) and ‘plane’ = ‘XY,’XZ’,’YZ’</p>
</dd>
</dl>
</dd>
</dl>
<p>Returns: None</p>
<p>An example photo-electron spectrum for the chiralim model molecule is shown below:</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/pes_example.png"><img alt="_images/pes_example.png" src="_images/pes_example.png" style="width: 400px; height: 400px;" /></a>
</figure>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.analyze.momentumfuncs.PES_plot">
<span class="sig-name descname"><span class="pre">PES_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">funcpars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spectrum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kgrid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irun</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plane</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.analyze.momentumfuncs.PES_plot" title="Permalink to this definition"></a></dt>
<dd><p>Produces a plot of the PES.</p>
<blockquote>
<div><p>It handles the case of <cite>W2D</cite> for selected 2D evaluation planes as well as the <cite>W2Dav</cite> case.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>kgrid</strong> – np.array of size (nkpoints): momentum grid in a.u.</p></li>
<li><p><strong>spectrum</strong> – array of size (nkpoints): 1D PES</p></li>
<li><p><strong>plot_params</strong> – parameters of the plot loaded from GRAPHICS.py</p></li>
<li><p><strong>plane</strong> – str
plane at which we calculate PES</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.analyze.momentumfuncs.W2Dav">
<span class="sig-name descname"><span class="pre">W2Dav</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">funcpars</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.analyze.momentumfuncs.W2Dav" title="Permalink to this definition"></a></dt>
<dd><p>2D electron momentum probability distribution averaged over the <span class="math notranslate nohighlight">\(\phi\)</span> angle.</p>
<p>A 2D slice <span class="math notranslate nohighlight">\(W(k,\tilde{\theta})\)</span> of the full 3D probability distribution <span class="math notranslate nohighlight">\(W(k, \tilde{\theta}, \tilde{\phi})\)</span> is calculated. A uniformly-weighted averaging over the azimuthal <span class="math notranslate nohighlight">\(\phi\)</span> angle is performed, to reflect the near-symmetry imposed multiple-cycle circularly-polarised light pulse that interacts with the molecule.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>W2Dav</cite> is a numpy.ndarray (complex) of shape (FT_npts_k, FT_npts_th). It is <strong>always</strong> defined on the original radial Hankel grid. Later this quantity can be interpolated for plotting in a custom radial range.</p>
</div>
<dl>
<dt>Parameters: dict</dt><dd><dl>
<dt>k_grid: dict</dt><dd><dl class="simple">
<dt>type<span class="classifier">‘manual’ or ‘automatic’</span></dt><dd><p>For ‘automatic’ we use the original FT grid (Hankel) to plot and process W2Dav.
For ‘manual’ we use a user-defined grid to plot W2Dav. This grid only cuts ranges. The base W2Dav is always defined over <cite>ft_polargrid</cite>.</p>
</dd>
</dl>
<p>kmin : used with ‘manual’ gives the minimum radial momentum value to plot</p>
<p>kmax : used with ‘manual’ gives the maximum radial momentum value to plot</p>
</dd>
<dt>th_grid: dict</dt><dd><p>thmin: gives the minimum angular value to plot</p>
<p>thmax: gives the maximum angular value to plot</p>
<p>FT_npts_th: numer of angular points at which W2Dav is evaluated, stored and plotted.</p>
</dd>
</dl>
<p>npts_phi: number of phi angles, distributed uniformly, that are used in phi-averaging</p>
</dd>
<dt>Arguments: dict</dt><dd><dl class="simple">
<dt>funcpars<span class="classifier">dict</span></dt><dd><p>A dictionary with all relevant W2Dav function parameters. See above.</p>
</dd>
</dl>
</dd>
<dt>Returns: tuple</dt><dd><dl class="simple">
<dt>obs_list<span class="classifier">list</span></dt><dd><p>A list of the form [i,t,obs_dict], where i is the time-index, t is the time and obs_dict is a dictionary of observables calculated at time t.</p>
</dd>
<dt>ft_polargrid: numpy.ndarray, shape = (FT_npts_k, FT_npts_th)</dt><dd><p>2D polar grid or <span class="math notranslate nohighlight">\((k,\tilde{\theta})\)</span></p>
</dd>
</dl>
</dd>
</dl>
<p>An example distribution is plotted below:</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/W2Dav_example.png"><img alt="_images/W2Dav_example.png" src="_images/W2Dav_example.png" style="width: 400px; height: 400px;" /></a>
</figure>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.analyze.momentumfuncs.W2Dav_calc">
<span class="sig-name descname"><span class="pre">W2Dav_calc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">funcpar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Flm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ft_polargrid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.analyze.momentumfuncs.W2Dav_calc" title="Permalink to this definition"></a></dt>
<dd><p>Calculate numerically <span class="math notranslate nohighlight">\(W_{2D}(k,\tilde{\theta};\tilde{\phi}_0)\)</span> for a sequence of phi angles and return averaged W2Dav.</p>
<p>A uniformly-weighted averaging over the azimuthal <span class="math notranslate nohighlight">\(\phi\)</span> angle is performed, to reflect the near-symmetry imposed multiple-cycle circularly-polarised light pulse that interacts with the molecule.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>W2Dav</cite> is a numpy.ndarray (complex) of shape (FT_npts_k, FT_npts_th). It is <strong>always</strong> defined on the original radial Hankel grid.</p>
</div>
<dl class="simple">
<dt>Arguments: dict</dt><dd><dl class="simple">
<dt>funcpars<span class="classifier">dict</span></dt><dd><p>A dictionary with all relevant W2Dav function parameters</p>
</dd>
<dt>Flm: numpy.ndarray, dtype = complex, shape = (FT_npts_k,)</dt><dd><p>Array of radial FT amplitudes calculated calculated with Hankel transform</p>
</dd>
<dt>ft_polargrid: numpy.ndarray, shape = (FT_npts_k, FT_npts_th)</dt><dd><p>2D polar grid or <span class="math notranslate nohighlight">\((k,\tilde{\theta})\)</span></p>
</dd>
</dl>
</dd>
<dt>Returns: numpy.ndarray</dt><dd><dl class="simple">
<dt>Wav<span class="classifier">numpy.ndarray, dtype = float, shape = (FT_npts_k,FT_npts_th)</span></dt><dd><p>Array keeping the phi-averaged 2D distribution.</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.analyze.momentumfuncs.W2Dav_plot">
<span class="sig-name descname"><span class="pre">W2Dav_plot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">funcpars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ft_polargrid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W2D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irun</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.analyze.momentumfuncs.W2Dav_plot" title="Permalink to this definition"></a></dt>
<dd><p>Produces a contour 2D plot for 2D phi-averaged electron’s momentum distribution <span class="math notranslate nohighlight">\(\bar{W}_{2D}(k,\tilde{\theta})\)</span></p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>In the present implementation the 2D controur plot is produced for the <strong>original FT</strong> grid, not for the grid defined by the user. User-defined grid determines ranges and ticks only.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><cite>contourf</cite> already performs interpolation of W2D. There is no need for evaluation of W2D on a finer grid than ft_polargrid.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.analyze.momentumfuncs.PESav">
<span class="sig-name descname"><span class="pre">PESav</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">funcpars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ft_polargrid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Wav</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">irun</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.analyze.momentumfuncs.PESav" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the photo-electron spectrum (PES) from a phi-averaged momentum distribution.</p>
<p>Perform the following integration:</p>
<div class="math notranslate nohighlight" id="equation-pes-definition">
<span class="eqno">(5)<a class="headerlink" href="#equation-pes-definition" title="Permalink to this equation"></a></span>\[\sigma(E) = \int \sin\theta d\theta \bar{W}_{2D}(E,\tilde{\theta})\]</div>
<p>This function carries options for:
a) saving the PES for a chosen momentum grid (<cite>save_PES=True</cite>)
b) psaving the PES for a chosen momentum grid (<cite>plot_PES=True</cite>)</p>
<dl class="simple">
<dt>Parameters: dict</dt><dd><dl class="simple">
<dt>pes_max_k: float</dt><dd><p>maximum range for the PES plot. It is independent of the respective momentum range set for W2Dav, but cannot exceed the FT range determined by the number of FT points.</p>
</dd>
</dl>
</dd>
<dt>Arguments: tuple</dt><dd><dl class="simple">
<dt>funcpars<span class="classifier">dict</span></dt><dd><p>parent function parameters. This includes <cite>funcpars[‘ktuple’]</cite> and <cite>funcpars[‘thtuple’]</cite>, which determine plotting ranges.</p>
</dd>
<dt>ft_polargrid<span class="classifier">numpy.ndarray, dtype = float, shape = ()</span></dt><dd><p>polar meshgrid over which the input distribution is defined. It has the shape = (FT_npts_k,npts_theta). The numer of angular points is arbitrary, as defined by the user in <cite>th_grid</cite>. The number of radial points is determined by the number of points used to calculate the Hankel transform.</p>
</dd>
<dt>Wav<span class="classifier">numpy.ndarray, dtype = float, shape = (FT_npts_k,npts_the)</span></dt><dd><p>array containing <span class="math notranslate nohighlight">\((E,\tilde{\theta})\)</span> on the FT radial grid and user-defined theta-grid.</p>
</dd>
</dl>
</dd>
</dl>
<p>Returns: None</p>
<p>An example photo-electron spectrum for the chiralim model molecule is shown below:</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/pes_example.png"><img alt="_images/pes_example.png" src="_images/pes_example.png" style="width: 400px; height: 400px;" /></a>
</figure>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pecd.analyze.momentumfuncs.legendre_expansion">
<span class="sig-name descname"><span class="pre">legendre_expansion</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">funcpars</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ft_polargrid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fdir</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pecd.analyze.momentumfuncs.legendre_expansion" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the Legendre expansion coefficients as a function of the photo-electron momentum.</p>
<p>Perform the following Legendre decomposition:</p>
<div class="math notranslate nohighlight" id="equation-legendre-expansion">
<span class="eqno">(6)<a class="headerlink" href="#equation-legendre-expansion" title="Permalink to this equation"></a></span>\[W(k,\tilde{\theta}) = \sum_{n=0}^{n_{max}} b_n(k)P_n(\cos\tilde{\theta})\]</div>
<p>where the expansion coefficients are given as:</p>
<div class="math notranslate nohighlight" id="equation-legendre-coeffs">
<span class="eqno">(7)<a class="headerlink" href="#equation-legendre-coeffs" title="Permalink to this equation"></a></span>\[b_n(k) =\frac{2n+1}{2}\int_{-1}^{1} W(k,\cos\tilde{\theta}))P_n(\cos\tilde{\theta}) d\cos\tilde{\theta}\]</div>
<p><span class="math notranslate nohighlight">\(n_{max}\)</span> is determined by <cite>Leg_Lmax</cite> in the input file.</p>
<p>For consisency with the angular range and definition of <cite>W2D</cite> we use <span class="math notranslate nohighlight">\(\theta=-np.arccos(x[:,0])+2.0*np.pi\)</span>. The respespective integral is calculated using the Gauss-Legendre quadrature:</p>
<div class="math notranslate nohighlight" id="equation-legendre-coeffs-quad">
<span class="eqno">(8)<a class="headerlink" href="#equation-legendre-coeffs-quad" title="Permalink to this equation"></a></span>\[b_n(k) =  \sum_{q=0}^{q_{max}} w_q P_n(\cos\tilde{\theta}_q) W(k,-\arccos(\cos\tilde{\theta})+2\pi)\]</div>
<p>where <span class="math notranslate nohighlight">\(q_{max}\)</span> is determined by <a href="#id3"><span class="problematic" id="id4">`</span></a>N_leg_quad’.</p>
<p>This function carries options for:
a) saving legendre expansion coefficients for a chosen momentum grid (<cite>save_bcoeffs=True</cite>)
b) plotting legendre expansion coefficients for a chosen momentum grid (<cite>plot_bcoeffs=True</cite>)</p>
<dl class="simple">
<dt>Parameters: dict</dt><dd><dl class="simple">
<dt>bcoeffs[‘k_grid’][‘kmin’], bcoeffs[‘k_grid’][‘kmax’],bcoeffs[‘k_grid’][‘npts’]</dt><dd><p>deterimine radial grid for plotting the b-coeffients</p>
</dd>
</dl>
</dd>
<dt>Arguments: tuple</dt><dd><dl class="simple">
<dt>funcpars<span class="classifier">dict</span></dt><dd><p>parent function parameters.</p>
</dd>
<dt>ft_polargrid<span class="classifier">numpy.ndarray, dtype = float, shape = ()</span></dt><dd><p>polar meshgrid over which the input distribution is defined. It has the shape = (FT_npts_k,FT_npts_th). The numer of angular points is arbitrary, as defined by the user in <cite>th_grid</cite>. The number of radial points is determined by the number of points used to calculate the Hankel transform.</p>
</dd>
<dt>fdir<span class="classifier">dict</span></dt><dd><p>dictionary containing the probability distribution(s) to be decomposed</p>
</dd>
</dl>
</dd>
<dt>Returns: tuple</dt><dd><dl class="simple">
<dt>bcoef<span class="classifier">numpy.ndarray, dtype = float, shape = (len(energy_grid),Legmax+1)</span></dt><dd><p>Array of the legendre expansion coefficients calculated at energies specified by the used in   params[‘legendre_params’][‘energy_grid’]</p>
</dd>
<dt>energy_grid: numpy.ndarray</dt><dd><p>energy grid on which the b-coeffs are calculated</p>
</dd>
</dl>
</dd>
</dl>
<p>An example plot of the legendre expansion coefficients (Legmax=20) vs. electron’s momentum (in a.u.) is plotted below (in log-scale):</p>
<figure class="align-center">
<a class="reference internal image-reference" href="_images/bcoeffs_example.png"><img alt="_images/bcoeffs_example.png" src="_images/bcoeffs_example.png" style="width: 400px; height: 400px;" /></a>
</figure>
</dd></dl>

</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="todolist.html" class="btn btn-neutral float-left" title="ToDo list" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Emil Zak.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>